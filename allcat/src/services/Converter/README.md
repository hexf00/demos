## 转换类型

无（文本）  单|多(选择、关联)
多 -> 单 丢弃多余项
单 -> 多 结构变数组
无 -> 单 不变
无 -> 多 逗号切割，增加选项
多 -> 无 逗号合并
单 -> 无 不变
文本、选择 -> 关联 明文变id(不存在新增或丢弃)
关联 -> 选择、文本 id变明文  
关联类型 还会在 目标表 创建反向关联字段

丢弃数据 是否需要提示用户？

delete 改用赋值undefined，性能上更有优势

不赋初始值，赋值时候使用$set，也可以减少导出数据的体积



关于选项

多个选项会出现相同值的选项，对于这些选项是否需要进行合并
对于空白选项，是否需要清空

选项可以做修改、删除的操作
修改、删除需要关联到行数据


选项有  label 、value  两个属性

正常情况来说，如从值获取得到所有选项， label 与 value相同 
编辑option列表只会编辑label，而不会编辑value，可以利用这点来判断

label 与 value 不相同  说明修改了，进行联动更新
label 不存在的，直接删除


值记录还有一个问题，我们需要去标注替换与没有替换的情况，
不进行标注的话将会存在替换错误的情况
说

'abc'.replace(/a/g,'b').replace(/b/g,'c').replace(/c/g,'a')
执行后 得到 aaa

这显然不是我们期望的结果
'abcd'.replace(/ab|cd/g, (i) => ({ab:'cd',cd:'ab'}[i]) )
每个元素只执行一次替换即可达到我们的期望



 文本转select时候
 用户可以编辑select的选项 
 飞书的逻辑是以选项列表为准 不在内的剔除 不在运行时添加选项
 这种方法可以识别用户的选项删除动作，用户删除了肯定是不想再有了



对于选项的删除，肯定要清理所有的引用


给到 A（原始）, B(现在) 
其实我们不能通过对比就判断 A改成了B  还是A被删除，新增了B

使用字面量 需要考虑 修改删除等

使用id 需要考虑 不同id到相同字面量的合并，也不利于全文检索
   但不影响导出

   最大的问题是，无法通过两份动作识别出修改了哪些内容，导致需要引入新的复杂度，引入新的参数


最终决定，选项不存储字面量，存储索引


为什么存储字面量，是为了git记录清晰可读。


维护选项列表时：
已有选项的两种可能性  删除 、修改 

删除分两种，彻底删除以及又新增了相同的字面量

关于选项合并，其实是需要去除重复选项。



